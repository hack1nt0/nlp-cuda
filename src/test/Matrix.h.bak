////
//// Created by DY on 17-8-5.
////
//
//#ifndef NLP_CUDA_MATRIX_H
//#define NLP_CUDA_MATRIX_H
//
//#include <istream>
//#include <vector>
//#include <cuda_runtime.h>
//#include <cusparse.h>
//#include <cublas_v2.h>
//#include <CudaUtils.cu>
//#include <cassert>
//#include <ostream>
//
//using namespace std;
//
//namespace cutils {
//    class CudaBlasContext {
//    public:
//        cublasHandle_t handle;
//
//        CudaBlasContext() {
//            cublasCreate(&handle);
//            cublasSetPointerMode(handle, CUBLAS_POINTER_MODE_HOST);
//        }
//
//        virtual ~CudaBlasContext() {
//            cublasDestroy(handle);
//        }
//    };
//
//    const CudaBlasContext cudaBlasContext;
//
//    class CudaSparseContext {
//    public:
//        cusparseHandle_t handle;
//
//        CudaSparseContext() {
//            cusparseCreate(&handle);
//            cusparseSetPointerMode(handle, CUSPARSE_POINTER_MODE_HOST);
//        }
//
//        virtual ~CudaSparseContext() {
//            cusparseDestroy(handle);
//        }
//    };
//
//    const CudaSparseContext cudaSparseContext;
//
//    template<typename T, typename LHS>
//    class BaseExpression {
//    public:
//        __device__ __host__
//        inline const LHS& self(void) const {
//            return *static_cast<const LHS *>(this);
//        }
//    };
//
//    template<typename T, typename LHS, typename RHS>
//    class AddExpression : public BaseExpression<T, AddExpression<T, LHS, RHS> > {
//    public:
//        const LHS &lhs;
//        const RHS &rhs;
//
//        AddExpression(const LHS &lhs, const RHS &rhs) : lhs(lhs), rhs(rhs) {}
//
//        __device__ __host__
//        inline T operator()(int r, int c) const {
//            return lhs(r, c) + rhs(r, c);
//        }
//        __device__ __host__
//        inline int rows() const {
//            return lhs.rows();
//        }
//
//        __device__ __host__
//        inline int cols() const {
//            return lhs.cols();
//        }
//    };
//
//    template<typename T, typename LHS, typename RHS>
//    class MinusExpression : public BaseExpression<T, MinusExpression<T, LHS, RHS> > {
//    public:
//        const LHS &lhs;
//        const RHS &rhs;
//
//        MinusExpression(const LHS &lhs, const RHS &rhs) : lhs(lhs), rhs(rhs) {}
//
//        __device__ __host__
//        inline T operator()(int r, int c) const {
//            return lhs(r, c) - rhs(r, c);
//        }
//        __device__ __host__
//        inline int rows() const {
//            return lhs.rows();
//        }
//
//        __device__ __host__
//        inline int cols() const {
//            return lhs.cols();
//        }
//    };
//
//    template<typename T, typename LHS, typename RHS>
//    class PowerExpression : public BaseExpression<T, PowerExpression<T, LHS, RHS> > {
//    public:
//        const LHS &lhs;
//        const RHS &rhs;
//
//        PowerExpression(const LHS &lhs, const RHS &rhs) : lhs(lhs), rhs(rhs) {}
//
//        __device__ __host__
//        inline T operator()(int r, int c) const {
//            return pow(lhs(r, c), rhs(r, c));
//        }
//        __device__ __host__
//        inline int rows() const {
//            return lhs.rows();
//        }
//
//        __device__ __host__
//        inline int cols() const {
//            return lhs.cols();
//        }
//    };
//
//    template<typename T, typename LHS, typename RHS>
//    class MultiplyExpression : public BaseExpression<T, MultiplyExpression<T, LHS, RHS> > {
//    public:
//        const LHS &lhs;
//        const RHS &rhs;
//
//        MultiplyExpression(const LHS &lhs, const RHS &rhs) : lhs(lhs), rhs(rhs) {}
//
//        __device__ __host__
//        inline T operator()(int r, int c) const {
//            return lhs(r, c) * rhs(r, c);
//        }
//        __device__ __host__
//        inline int rows() const {
//            return lhs.rows();
//        }
//
//        __device__ __host__
//        inline int cols() const {
//            return lhs.cols();
//        }
//    };
//
//    template<typename T, typename LHS, typename RHS>
//    class DivideExpression : public BaseExpression<T, DivideExpression<T, LHS, RHS> > {
//    public:
//        const LHS &lhs;
//        const RHS &rhs;
//
//        DivideExpression(const LHS &lhs, const RHS &rhs) : lhs(lhs), rhs(rhs) {}
//
//        __device__ __host__
//        inline T operator()(int r, int c) const {
//            return lhs(r, c) / rhs(r, c);
//        }
//
//        __device__ __host__
//        inline int rows() const {
//            return lhs.rows();
//        }
//
//        __device__ __host__
//        inline int cols() const {
//            return lhs.cols();
//        }
//    };
//
//    template<typename T, typename LHS, typename RHS>
//    inline
//    AddExpression<T, LHS, RHS> operator+(const BaseExpression<T, LHS> &lhs, const BaseExpression<T, RHS> &rhs) {
//        return AddExpression<T, LHS, RHS>(lhs.self(), rhs.self());
//    }
//
//    template<typename T, typename LHS, typename RHS>
//    inline
//    MinusExpression<T, LHS, RHS> operator-(const BaseExpression<T, LHS> &lhs, const BaseExpression<T, RHS> &rhs) {
//        return MinusExpression<T, LHS, RHS>(lhs.self(), rhs.self());
//    }
//
//    template<typename T, typename LHS, typename RHS>
//    inline
//    PowerExpression<T, LHS, RHS> operator^(const BaseExpression<T, LHS> &lhs, const BaseExpression<T, RHS> &rhs) {
//        return PowerExpression<T, LHS, RHS>(lhs.self(), rhs.self());
//    }
//
//    template<typename T, typename LHS, typename RHS>
//    inline
//    MultiplyExpression<T, LHS, RHS> operator<<(const BaseExpression<T, LHS> &lhs, const BaseExpression<T, RHS> &rhs) {
//        return MultiplyExpression<T, LHS, RHS>(lhs.self(), rhs.self());
//    }
//
//    template<typename T, typename LHS, typename RHS>
//    inline
//    DivideExpression<T, LHS, RHS> operator>>(const BaseExpression<T, LHS> &lhs, const BaseExpression<T, RHS> &rhs) {
//        return DivideExpression<T, LHS, RHS>(lhs.self(), rhs.self());
//    }
//
//    template<typename T, typename LHS>
//    class TransposeExpression : public BaseExpression<T, TransposeExpression<T, LHS> > {
//    public:
//        const LHS &lhs;
//
//        TransposeExpression(const LHS &lhs) : lhs(lhs) {}
//
//        __device__ __host__
//        inline T operator()(int r, int c) const {
//            return lhs(c, r);
//        }
//
//        __device__ __host__
//        inline int rows() const {
//            return lhs.rows();
//        }
//
//        __device__ __host__
//        inline int cols() const {
//            return lhs.cols();
//        }
//    };
//
//    template<class T, class LHS>
//    inline TransposeExpression<T, LHS> operator~(const BaseExpression<T, LHS> &expression) {
//        return TransposeExpression<T, LHS>(expression.self());
//    }
//
//    template<typename T, typename LHS>
//    class SumExpression : public BaseExpression<T, SumExpression<T, LHS> > {
//    public:
//        const LHS &lhs;
//        int index;
//
//        SumExpression(const LHS &lhs, int index) : lhs(lhs), index(index) {}
//
//        __device__ __host__
//        inline T operator()(int r, int c) const {
//            T sum = 0;
//            if (index == 0) {
//                for (int i = 0; i < lhs.rows(); ++i) {
//                    sum += lhs(i, c);
//                }
//            } else {
//                for (int i = 0; i < lhs.cols(); ++i) {
//                    sum += lhs(r, i);
//                }
//
//            }
//            return sum;
//        }
//
//        __device__ __host__
//        inline int rows() const {
//            return index == 0 ? 1 : lhs.rows();
//        }
//
//        __device__ __host__
//        inline int cols() const {
//            return index == 0 ? lhs.cols() : 1;
//        }
//    };
//
//    template<class T, class LHS>
//    inline SumExpression<T, LHS> sum(const BaseExpression<T, LHS> &expression, int index) {
//        return SumExpression<T, LHS>(expression.self(), index);
//    }
//
//    template<typename T>
//    class ConstMatrix : public BaseExpression<T, ConstMatrix<T> > {
//    public:
//        T _data;
//
//        ConstMatrix(T data) {
//            this->_data = data;
//        }
//
//        __device__ __host__
//        inline T operator()(int r, int c) const {
//            return _data;
//        }
//
//        __device__ __host__
//        inline T operator()(int i) const {
//            return _data;
//        }
//    };
//
//    template <typename T, typename LHS>
//    class BaseSparseExpression{
//    public:
//        inline const LHS& self(void) const {
//            return *static_cast<const LHS*>(this);
//        }
//    };
//
//    template <typename T, typename LHS, typename RHS>
//    class SparsePowerExpression : public BaseSparseExpression<T,  SparsePowerExpression<T, LHS, RHS> > {
//    public:
//        const LHS &lhs;
//        const RHS &rhs;
//
//        SparsePowerExpression(const LHS &lhs, const RHS &rhs) : lhs(lhs), rhs(rhs) {}
//
//        __device__ __host__
//        inline T operator()(int i) const {
//            return pow(lhs(i), rhs(i));
//        }
//
//        __device__ __host__
//        inline int rows() const {
//            return lhs.rows();
//        }
//
//        __device__ __host__
//        inline int cols() const {
//            return lhs.cols();
//        }
//
//        __device__ __host__
//        inline int nnz() const {
//            return lhs.nnz();
//        }
//
//        __device__ __host__
//        inline int* index() const {
//            return lhs.index();
//        }
//
//        __device__ __host__
//        inline int* row_ptr() const {
//            return lhs.row_ptr();
//        }
//
//    };
//
//    template<class T, class LHS, class RHS = ConstMatrix<T> >
//    SparsePowerExpression<T, LHS, RHS> operator^(const BaseSparseExpression<T, LHS> &baseSparseExpression, T value) {
//        return SparsePowerExpression<T, LHS, RHS >(baseSparseExpression.self(), ConstMatrix<T>(value));
//    }
//
//    template<typename T, typename LHS, class RHS>
//    SparsePowerExpression<T, LHS, RHS> operator^(const BaseSparseExpression<T, LHS> &lhs, const BaseSparseExpression<T, RHS> &rhs) {
//        return SparsePowerExpression<T, LHS, RHS>(lhs.self(), rhs.self());
//    }
//
//    template<typename T, typename LHS, class RHS>
//    SparsePowerExpression<T, LHS, RHS> operator^(const BaseSparseExpression<T, LHS> &lhs, const BaseExpression<T, RHS> &rhs) {
//        return SparsePowerExpression<T, LHS, RHS>(lhs.self(), rhs.self());
//    }
//
//    template <typename T, typename LHS>
//    class SparseTransposeExpression : public BaseSparseExpression<T,  SparseTransposeExpression<T, LHS> > {
//    public:
//        const LHS &lhs;
//
//        SparseTransposeExpression(const LHS &lhs) : lhs(lhs) {}
//    };
//
//    template<typename T, typename ETYPE>
//    SparseTransposeExpression<T, ETYPE> operator~(const BaseSparseExpression<T, ETYPE> &baseSparseExpression) {
//        return SparseTransposeExpression<T, ETYPE>(baseSparseExpression.self());
//    }
//
//    template <typename T, typename LHS, typename RHS>
//    class SparseTransposeDotDenseExpression : public BaseSparseExpression<T,  SparseTransposeDotDenseExpression<T, LHS, RHS> > {
//    public:
//        const SparseTransposeExpression<T, LHS> &lhs;
//        const RHS &rhs;
//
//        SparseTransposeDotDenseExpression(const SparseTransposeExpression<T, LHS> &lhs, const RHS &rhs) : lhs(lhs), rhs(rhs) {}
//    };
//
//    template<typename T, typename LHS, typename RHS>
//    SparseTransposeDotDenseExpression<T, LHS, RHS> operator*(const SparseTransposeExpression<T, LHS> &lhs, const BaseExpression<T, RHS> &rhs) {
//        return SparseTransposeDotDenseExpression<T, LHS, RHS>(lhs.self(), rhs.self());
//    }
//
//
//    template<typename T>
//    class DeviceSparseMatrix : public BaseSparseExpression<T, DeviceSparseMatrix<T> > {
//    public:
//        T *_data;
//        int *_index;
//        int *_row_ptr;
//        int _rows, _cols, _nnz;
//        cusparseMatDescr_t descr;
//
//        DeviceSparseMatrix() {}
//
//        DeviceSparseMatrix(const vector<T> &data, const vector<int> &index, const vector<int> &row_ptr, int rows, int cols) {
//            checkCudaErrors(cudaMalloc((void **) &this->_data, sizeof(T) * data.size()));
//            checkCudaErrors(cudaMemcpy(this->_data, data.data(), sizeof(T) * data.size(), cudaMemcpyHostToDevice));
//            checkCudaErrors(cudaMalloc((void **) &this->_index, sizeof(int) * index.size()));
//            checkCudaErrors(cudaMemcpy(this->_index, index.data(), sizeof(int) * index.size(), cudaMemcpyHostToDevice));
//            checkCudaErrors(cudaMalloc((void **) &this->_row_ptr, sizeof(int) * row_ptr.size()));
//            checkCudaErrors(cudaMemcpy(this->_row_ptr, row_ptr.data(), sizeof(int) * row_ptr.size(), cudaMemcpyHostToDevice));
//            this->_rows = rows;
//            this->_cols = cols;
//            this->_nnz = data.size();
//            checkCusparseErrors(cusparseCreateMatDescr(&descr));
//            cusparseSetMatType(descr, CUSPARSE_MATRIX_TYPE_GENERAL);
//            cusparseSetMatIndexBase(descr, CUSPARSE_INDEX_BASE_ZERO);
//        }
//
//        DeviceSparseMatrix(const DeviceSparseMatrix<T> &that) {
//            checkCudaErrors(cudaMalloc((void **) &this->_data, sizeof(T) * that._nnz));
//            checkCudaErrors(cudaMemcpy(this->_data, that._data, sizeof(T) * that._nnz, cudaMemcpyDeviceToDevice));
//            this->_index = that._index;
//            this->_row_ptr = that._row_ptr;
//            this->_rows = that._rows;
//            this->_cols = that._cols;
//            this->_nnz = that._nnz;
//            this->descr = that.descr;
//        }
//
//        template <class ETYPE>
//        DeviceSparseMatrix(const BaseSparseExpression<T, ETYPE> &sparseExpression) {
//            const ETYPE &expression = sparseExpression.self();
//            this->_rows = expression.rows();
//            this->_cols = expression.cols();
//            this->_nnz = expression.nnz();
//            this->_index = expression.index();
//            this->_row_ptr = expression.row_ptr();
//            checkCudaErrors(cudaMalloc((void **) &this->_data, sizeof(T) * this->_nnz));
//            mapDevice(_data, expression, this->_nnz);
//            checkCudaErrors(cudaDeviceSynchronize());
//        }
//
//        virtual ~DeviceSparseMatrix() {
//            cudaFree(_data);
//            cudaFree(_index);
//            cudaFree(_row_ptr);
//            checkCusparseErrors(cusparseDestroyMatDescr(descr));
//        }
//
//        friend ostream &operator<<(ostream &os, const DeviceSparseMatrix<T> &matrix) {
//            HostArray<T> data(matrix.nnz());
//            checkCudaErrors(cudaMemcpy(data.data, matrix._data, sizeof(T) * data.size, cudaMemcpyDeviceToHost));
//            HostArray<int> index(matrix.nnz());
//            checkCudaErrors(cudaMemcpy(index.data, matrix._index, sizeof(int) * index.size, cudaMemcpyDeviceToHost));
//            HostArray<int> row_ptr(matrix.rows() + 1);
//            checkCudaErrors(cudaMemcpy(row_ptr.data, matrix._row_ptr, sizeof(int) * row_ptr.size, cudaMemcpyDeviceToHost));
//            std::cout << matrix.rows() << '\t' <<  matrix.cols() << '\t' << matrix.nnz() << std::endl;
//            data.print("data", 100);
//            index.print("index", 100);
//            row_ptr.print("row_ptr", 100);
//            return os;
//        }
//
//        template<typename ETYPE>
//        inline
//        DeviceSparseMatrix<T> &operator=(const BaseSparseExpression<T, ETYPE> &baseExpression) {
//            const ETYPE &expression = baseExpression.self();
//            fillDevice(_data, expression, _nnz);
//            checkCudaErrors(cudaDeviceSynchronize());
//            return *this;
//        }
//
//        __device__ __host__
//        inline T operator()(int i) const {
//            return _data[i];
//        }
//
//        __device__ __host__
//        inline int rows() const {
//            return _rows;
//        }
//
//        __device__ __host__
//        inline int cols() const {
//            return _cols;
//        }
//
//        __device__ __host__
//        inline int nnz() const {
//            return _nnz;
//        }
//
//        __device__ __host__
//        inline int* index() const {
//            return _index;
//        }
//
//        __device__ __host__
//        inline int* row_ptr() const {
//            return _row_ptr;
//        }
//    };
//
//    //Row based
//    template <typename T>
//    class DeviceDenseMatrix : public BaseExpression<T, DeviceDenseMatrix<T> > {
//    public:
//        T *data;
//        int _rows, _cols;
//
//        DeviceDenseMatrix(vector<T> &data, int rows, int cols) {
//            checkCudaErrors(cudaMalloc((void **) &this->data, sizeof(T) * data.size()));
//            checkCudaErrors(cudaMemcpy(this->data, data.data(), sizeof(T) * data.size(), cudaMemcpyHostToDevice));
//            this->_rows = rows;
//            this->_cols = cols;
//        }
//
//        DeviceDenseMatrix(int initial_value, int rows, int cols) {
//            assert(-128 <= initial_value && initial_value < 128);
//            int size = rows * cols;
//            checkCudaErrors(cudaMalloc((void **) &this->data, sizeof(T) * size));
//            checkCudaErrors(cudaMemset(this->data, initial_value, sizeof(T) * size));
//            checkCudaErrors(cudaDeviceSynchronize());
//            this->_rows = rows;
//            this->_cols = cols;
//        }
//
//        DeviceDenseMatrix(int rows, int cols) {
//            int size = rows * cols;
//            checkCudaErrors(cudaMalloc((void **) &this->data, sizeof(T) * size));
//            this->_rows = rows;
//            this->_cols = cols;
//        }
//
//        virtual ~DeviceDenseMatrix() {
//            checkCudaErrors(cudaFree(data));
//        }
//
//        static void cudaSparseMultiplyDense(DeviceDenseMatrix<T> &C, float beta,
//                                            const DeviceSparseMatrix<T> &A, bool transposeA, float alpha,
//                                            const DeviceDenseMatrix<T> &B, bool transposeB) {
//            cusparseOperation_t transA = transposeA ? CUSPARSE_OPERATION_TRANSPOSE : CUSPARSE_OPERATION_NON_TRANSPOSE;
//            cusparseOperation_t transB = transposeB ? CUSPARSE_OPERATION_TRANSPOSE : CUSPARSE_OPERATION_NON_TRANSPOSE;
//            checkCusparseErrors(
//                    cusparseScsrmm2(cudaSparseContext.handle, //todo
//                                   transA,
//                                   transB,
//                                   A._rows,
//                                   B._cols,
//                                   A._cols,
//                                   A._nnz,
//                                   &alpha,
//                                   A.descr,
//                                   A._data,
//                                   A._row_ptr,
//                                   A._index,
//                                   B.data,
//                                   B._rows,
//                                   &beta,
//                                   C.data,
//                                   C._rows)
//            );
//
//        }
//
//        template<typename LHS, typename RHS>
//        inline
//        DeviceDenseMatrix<T> &operator=(const SparseTransposeDotDenseExpression<T, LHS, RHS> &expression) {
//            const DeviceSparseMatrix<T> &sparseMatrix = expression.lhs.lhs.self();
//            cout << sparseMatrix << endl;
//            const DeviceDenseMatrix<T> &denseMatrix = expression.rhs.self();
////            cout << denseMatrix << endl;
//            cudaSparseMultiplyDense(*this, 0.0f, sparseMatrix, true, 1.0f, denseMatrix, false);
//            checkCudaErrors(cudaDeviceSynchronize());
//            printf("sparse dense multi done.\n");
//            return *this;
//        }
//
//        template <typename ETYPE>
//        inline
//        DeviceDenseMatrix<T> &operator=(const BaseExpression<T, ETYPE> &baseExpression) {
//            fillDevice(data, baseExpression.self(), _rows, _cols);
//            checkCudaErrors(cudaDeviceSynchronize());
//            return *this;
//        }
//
//        template <typename ETYPE>
//        inline
//        DeviceDenseMatrix<T> &operator+=(const BaseExpression<T, ETYPE> &baseExpression) {
//            *this = *this + baseExpression;
//            return *this;
//        }
//
//        template <class LHS, class RHS>
//        DeviceDenseMatrix<T> &operator+=(const SparseTransposeDotDenseExpression<T, LHS, RHS> &expression) {
//            DeviceSparseMatrix<T> sparseMatrix = expression.lhs.lhs.self();
//            DeviceDenseMatrix<T> denseMatrix = expression.rhs.self();
//            cudaSparseMultiplyDense(*this, 1.0f, sparseMatrix, true, 1.0f, denseMatrix, false);
//            return *this;
//        }
//
//        template <typename ETYPE>
//        inline
//        DeviceDenseMatrix &operator-=(const BaseExpression<T, ETYPE> &baseExpression) {
//            *this = *this - baseExpression;
//            return *this;
//        }
//
//        inline
//        DeviceDenseMatrix &operator>=(const DeviceDenseMatrix<T> &deviceDenseMatrix) {
//            *this = *this > deviceDenseMatrix;
//            return *this;
//        }
//
//        inline
//        DeviceDenseMatrix &operator>=(const T &value) {
//            *this = *this > value;
//            return *this;
//        }
//
//        __device__ __host__
//        inline T operator()(int r, int c) const {
//            return data[r * _cols + c];
//        }
//
//        __device__ __host__
//        inline int rows() const {
//            return _rows;
//        }
//
//        __device__ __host__
//        inline int cols() const {
//            return _cols;
//        }
//
//        void reshape(int rows, int cols) {
//            assert(rows * cols == this->_rows * this->_cols && rows > 0 && cols > 0);
//            this->_rows = rows;
//            this->_cols = cols;
//        }
//
//        friend ostream &operator<<(ostream &os, const DeviceDenseMatrix<T> &matrix) {
//            int size = matrix.rows() * matrix.cols();
//            T *data = new T[size];
//            checkCudaErrors(cudaMemcpy(data, matrix.data, sizeof(T) * size, cudaMemcpyDeviceToHost));
//            for (int i = 0; i < matrix.rows(); ++i) {
//                for (int j = 0; j < matrix.cols(); ++j) {
//                    os << data[i * matrix.cols() + j] << "\t";
//                }
//                os << endl;
//            }
//            delete[] data;
//            return os;
//        }
//    };
//
//    template <typename T>
//    class ScatterMatrix : public BaseExpression<T, ScatterMatrix<T> > {
//    public:
//        const DeviceDenseMatrix<T> &deviceDenseMatrix;
//        int rows, cols;
//
//        ScatterMatrix(const DeviceDenseMatrix<T> &deviceDenseMatrix) : deviceDenseMatrix(deviceDenseMatrix), rows(deviceDenseMatrix._rows), cols(deviceDenseMatrix._cols) {}
//
//        __device__ __host__
//        inline T operator()(int r, int c) const {
//            return deviceDenseMatrix(r % rows, c % cols);
//        }
//    };
//
//    /*
//     * Broadcast ops
//     */
//    template<typename T, typename LHS>
//    inline
//    PowerExpression<T, LHS, ScatterMatrix<T> > operator^(const BaseExpression<T, LHS> &lhs, const DeviceDenseMatrix<T> &rhs) {
//        ScatterMatrix<T> scatterMatrix(rhs);
//        return PowerExpression<T, LHS, ScatterMatrix<T> >(lhs.self(), scatterMatrix);
//    }
//
//    template<typename T, typename LHS, class RHS = ConstMatrix<T> >
//    inline
//    PowerExpression<T, LHS, RHS> operator^(const BaseExpression<T, LHS> &lhs, T rhs) {
//        return PowerExpression<T, LHS, RHS>(lhs.self(), ConstMatrix<T>(rhs));
//    }
//
//    template<typename T, typename LHS>
//    inline
//    MultiplyExpression<T, LHS, ScatterMatrix<T> > operator<(const BaseExpression<T, LHS> &lhs, const DeviceDenseMatrix<T> &rhs) {
//        return MultiplyExpression<T, LHS, ScatterMatrix<T> >(lhs.self(), ScatterMatrix<T>(rhs));
//    }
//
//    template<typename T, typename LHS>
//    inline
//    MultiplyExpression<T, LHS, ConstMatrix<T> > operator<(const BaseExpression<T, LHS> &lhs, T rhs) {
//        return MultiplyExpression<T, LHS, ConstMatrix<T> >(lhs.self(), ConstMatrix<T>(rhs));
//    }
//
//    template<typename T, typename LHS>
//    inline
//    DivideExpression<T, LHS, ScatterMatrix<T> > operator>(const BaseExpression<T, LHS> &lhs, const DeviceDenseMatrix<T> &rhs) {
//        return DivideExpression<T, LHS, ScatterMatrix<T> >(lhs.self(), ScatterMatrix<T>(rhs));
//    }
//
//    template<typename T, typename LHS>
//    inline
//    DivideExpression<T, LHS, ConstMatrix<T> > operator>(const BaseExpression<T, LHS> &lhs, const T &rhs) {
//        return DivideExpression<T, LHS, ConstMatrix<T> >(lhs.self(), ConstMatrix<T>(rhs));
//    }
//
//    template <class T>
//    class device_matrix : public BaseExpression<T, device_matrix<T> > {
//    public:
//        vector<T> data;
//        int _rows, _cols;
//
//        device_matrix() {}
//
//        static device_matrix generateRandomMatrix(int rows, int cols) {
//            device_matrix matrix;
//            matrix._rows = rows;
//            matrix._cols = cols;
//            for (int i = 0; i < rows * cols; ++i)
//                matrix.data.push_back((T)(rand() % 100));
//            return matrix;
//        }
//
//        template <class ETYPE>
//        device_matrix(const BaseExpression<T, ETYPE> &expression) {
//            const ETYPE &etype = expression.self();
//            this->_rows = etype.rows();
//            this->_cols = etype.cols();
//            for (int i = 0; i < _rows; ++i)
//                for (int j = 0; j < _cols; ++j) this->data.push_back(etype(i, j));
//        }
//
//        template <class ETYPE>
//        device_matrix& operator=(const BaseExpression<T, ETYPE> &expression) {
//            const ETYPE &etype = expression.self();
//            if (this->_rows * this->_cols != etype.rows() * etype.cols()) {
//                this->_rows = etype.rows();
//                this->_cols = etype.cols();
//                this->data.clear(); //todo;
//                for (int i = 0; i < _rows; ++i)
//                    for (int j = 0; j < _cols; ++j) this->data.push_back(etype(i, j));
//            } else {
//                this->_rows = etype.rows();
//                this->_cols = etype.cols();
//                for (int i = 0; i < _rows; ++i)
//                    for (int j = 0; j < _cols; ++j) this->data[i * this->cols() + j] = etype(i, j);
//            }
//        }
//
//        inline T operator()(int r, int c) const {
//            return data[r * _cols + c];
//        }
//
//        inline int rows() const {
//            return _rows;
//        }
//
//        inline int cols() const {
//            return _cols;
//        }
//
//        friend ostream &operator<<(ostream &os, const device_matrix &matrix) {
//            os << "HostDenseMatrix [rows, cols] = [" << matrix.rows() << ", " << matrix.cols() << "]" << endl;
//            for (int i = 0; i < matrix.rows(); ++i) {
//                for (int j = 0; j < matrix.cols(); ++j) {
//                    printf("%10.3f\t", matrix.data[i * matrix.cols() + j]);
//                }
//                os << endl;
//            }
//            return os;
//        }
//    };
//
//    template <class T>
//    class SparseMatrix : public BaseSparseExpression<T, SparseMatrix<T> > {
//    public:
//        T *_data;
//        int *_index;
//        int *_row_ptr;
//        int _rows, _cols, _nnz;
//
//        SparseMatrix() {}
//
//        virtual ~SparseMatrix() {
//            delete[] _data;
//            delete[] _index;
//            delete[] _row_ptr;
//        }
//
//        static SparseMatrix generateRandomSparseMatrix(int rows, int cols, float density) {
//            SparseMatrix matrix;
//            matrix._rows = rows;
//            matrix._cols = cols;
//            matrix._row_ptr = new int[rows + 1];
//            matrix._row_ptr[0] = 0;
//            vector<T> data;
//            vector<int> index;
//            srand(time(0));
//            matrix._nnz = 0;
//            for (int i = 0; i < rows; ++i) {
//                int count = 0;
//                for (int j = 0; j < cols; ++j) {
//                    float p = (float) rand() / RAND_MAX;
//                    if (p < density) {
//                        data.push_back((T)p);
//                        index.push_back(j);
//                        matrix._nnz++;
//                        count++;
//                    }
//                }
//                matrix._row_ptr[i + 1] = (count + matrix._row_ptr[i]);
//            }
//            matrix._data = data.data();
//            matrix._index = index.data();
//            return matrix;
//        }
//
//        SparseMatrix(const SparseMatrix<T> &that) {
//            printf("copy\n");
//            *this = that;
//        }
//
//        inline SparseMatrix &operator=(const SparseMatrix<T> &that) {
//            printf("=\n");
//            if (this != &that) {
//                this->_rows = that.rows();
//                this->_cols = that.cols();
//                this->_nnz = that.nnz();
//                this->_data = new T[this->_nnz];
//                for (int i = 0; i < this->_nnz; ++i) this->_data[i] = that._data[i];
//                this->_index = new int[this->_nnz];
//                for (int i = 0; i < this->_nnz; ++i) this->_index[i] = that._index[i];
//                this->_row_ptr = new int[this->_rows + 1];
//                for (int i = 0; i < this->_rows + 1; ++i) this->_row_ptr[i] = that._row_ptr[i];
//            }
//            return *this;
//        }
//
//
//        template <class ETYPE>
//        SparseMatrix(const BaseSparseExpression<T, ETYPE> &sparseExpression) {
//            const ETYPE &expression = sparseExpression.self();
//            this->_rows = expression.rows();
//            this->_cols = expression.cols();
//            this->_index = expression.index();
//            this->_row_ptr = expression.row_ptr();
//            this->_nnz = expression.nnz();
//            this->_data = new T[this->nnz()];
//            for (int i = 0; i < this->_nnz; ++i) this->_data[i] = expression(i);
//        }
//
//        template <class ETYPE>
//        inline SparseMatrix &operator=(const BaseSparseExpression<T, ETYPE> &sparseExpression) {
//            const ETYPE &expression = sparseExpression.self();
//            this->_rows = expression.rows();
//            this->_cols = expression.cols();
//            this->_index = expression.index();
//            this->_row_ptr = expression.row_ptr();
//            if (this->nnz() != expression.nnz()) {
//                this->_nnz = expression.nnz();
//                delete[] this->_data;
//                this->_data = new T[this->nnz()];
//            }
//            for (int i = 0; i < this->_nnz; ++i) this->_data[i] = expression(i);
//            return *this;
//        }
//
//        inline T operator()(int i) const {
//            return _data[i];
//        }
//
//        inline int rows() const {
//            return _rows;
//        }
//
//        inline int cols() const {
//            return _cols;
//        }
//
//        inline int nnz() const {
//            return _nnz;
//        }
//
//        inline int* index() const {
//            return _index;
//        }
//
//        inline int* row_ptr() const {
//            return _row_ptr;
//        }
//
//
//        friend ostream &operator<<(ostream &os, const SparseMatrix &matrix) {
//            os << "SparseMatrix [rows, cols, nnz] = [" << matrix.rows() << ", " << matrix.cols() << ", " << matrix.nnz() << "]" << endl;
//            for (int i = 0; i < matrix._rows; ++i) {
//                int from = matrix._row_ptr[i], to = matrix._row_ptr[i + 1];
//                for (int j = 0; j < matrix._cols; ++j) {
//                    if (from < to && j == matrix._index[from]) {
//                        printf("%10.3f\t", matrix._data[from++]);
//                    } else {
//                        printf("%10s\t", ".");
//                    }
//                }
//                os << endl;
//            }
//            return os;
//        }
//    };
//
//}
//#endif //NLP_CUDA_MATRIX_H
